mode_phase = getmode(exclude_3SD((
abs(Phase))))
)
##
## STATS Power vs Frequency (1/f noise)
##
Sim_lmer_power_freq_Stimulus <- lmer(log(Power_Stimulus) ~ log(freq) + (1|subject_id), data = Sim_Power_Spectra[Sim_Power_Spectra$freq > 0.01 & Sim_Power_Spectra$freq < 0.1 & is.finite(log(Sim_Power_Spectra$Power_Stimulus)),])
Sim_STAT.lmer_power_freq_Stimulus <- summary(Sim_lmer_power_freq_Stimulus)
Sim_lmer_power_freq_History <- lmer(log(Power_History) ~ log(freq) + (1|subject_id), data = Sim_Power_Spectra[Sim_Power_Spectra$freq > 0.01 & Sim_Power_Spectra$freq < 0.1 & is.finite(log(Sim_Power_Spectra$Power_History)),])
Sim_STAT.lmer_power_freq_History <- summary(Sim_lmer_power_freq_History)
##
## Simulated modes
##
Sim_Mode_gather <-  ddply(
Sim,
.(subject_id),
summarise,
directed_mode = round((round(Accuracy_slider, digits = 1) - round(History_slider, digits = 1))*100, digits = 0),
scaled_directed_mode = scale(directed_mode),
strength_mode = abs(scaled_directed_mode)
)
Sim$directed_mode = Sim_Mode_gather$directed_mode
Sim$scaled_directed_mode = Sim_Mode_gather$scaled_directed_mode
Sim$strength_mode = Sim_Mode_gather$strength_mode
Sim_ID_mode <-  ddply(
Sim,
.(subject_id),
summarise,
strength_mode = mean(strength_mode, na.rm = TRUE),
directed_mode = mean(directed_mode, na.rm = TRUE)
)
##
## Simulated confidence
##
Sim$Confidence <- abs(Sim$mu)
Sim$scaled_Confidence <- scale(Sim$Confidence)
Sim$clear_Confidence <- Sim$Confidence
Sim[Sim$clear_Confidence > median(Sim$clear_Confidence, na.rm = TRUE) + 3*median(Sim$clear_Confidence, na.rm = TRUE),]$clear_Confidence <- NA
Sim_Post_Perceptual_Modes = ddply(
Sim[!is.na(Sim$History) & !is.na(Sim$Accuracy) & !is.na(Sim$clear_Confidence),],
.(directed_mode),
summarise,
average_Confidence = mean(clear_Confidence, na.rm = TRUE),
se_Confidence = sd(clear_Confidence, na.rm = TRUE)/sqrt(length(clear_Confidence)),
n = length(mu),
n_percent = (sum(!is.na(mu))/nrow(Sim))*100
)
Sim_slider_History_vs_Accuracy <- lmer(History_slider ~ Accuracy_slider + (1|subject_id), data = Sim)
Sim_STAT.slider_History_vs_Accuracy <- summary(Sim_slider_History_vs_Accuracy)
##
## Confidence vs mode: Prepare plot and stats
##
Sim_Confidence_Behav <-
ddply(
Sim[!is.na(Sim$History) & !is.na(Sim$Accuracy) & !is.na(Sim$clear_Confidence),],
.(subject_id),
summarise,
diff_Confidence_History = mean(clear_Confidence[History == 1], na.rm = TRUE) -  mean(clear_Confidence[History == 0], na.rm = TRUE),
diff_Confidence_Stimulus = mean(clear_Confidence[Accuracy == 1], na.rm = TRUE) -  mean(clear_Confidence[Accuracy == 0], na.rm = TRUE)
)
gathercol = colnames(Sim_Confidence_Behav[, c(2,3)])
Sim_Confidence_Behav_long  <-
gather(Sim_Confidence_Behav[,c(1,2,3)],
"Variable",
"diff",
gathercol,
factor_key = TRUE)
Sim_Confidence_Behav_long$Variable <-
gsub("diff_Confidence_History", "History", Sim_Confidence_Behav_long$Variable)
Sim_Confidence_Behav_long$Variable <-
gsub("diff_Confidence_Stimulus", "Stimulus", Sim_Confidence_Behav_long$Variable)
Sim_diff_Confidence <- lmer(diff ~ Variable + (1|subject_id), data = Sim_Confidence_Behav_long)
Sim_STAT.diff_Confidence <- summary(Sim_diff_Confidence)
## exclude low performance mice
Summary_Sim_Confidence_Behav <-
ddply(
Sim_Confidence_Behav_long,
.(Variable),
summarise,
Mean = mean(diff, na.rm = TRUE),
Error = sd(diff, na.rm = TRUE)/sqrt(length(diff)))
Sim_lmer_Confidence_Accuracy_History <- lmer(clear_Confidence ~ Accuracy + History + (1|subject_id), data = Sim)
Sim_STAT.lmer_Confidence_Accuracy_History <- summary(Sim_lmer_Confidence_Accuracy_History)
##
## Confidence vs. mode
##
Sim_Confidence_vs_mode <- lmer(clear_Confidence ~ poly(directed_mode, 2) + (1|subject_id), data = Sim)
Sim_STAT.Confidence_vs_mode <- summary(Sim_Confidence_vs_mode)
gathercol <- colnames(Sim_Behav[,c(3,6)])
Sim_Behav_long  <-
gather(Sim_Behav[, c(1,2,3,6)],
"Variable",
"Frequency",
gathercol,
factor_key = TRUE)
Sim_Behav_long$Frequency <-
gsub("Accuracy", "Stimulus", Sim_Behav_long$Frequency)
sim_p_distribution_Behav <- ggplot(Sim_Behav_long, aes(x = as.numeric(Frequency), color = Variable, fill = Variable)) +
geom_density(colour = "white", alpha=.4, bw = 0.75, size = 0.5) +
theme_classic(base_size = 6) +  xlim(25 , 100) + labs(x = "Frequency (%)",  y = "Density", subtitle = "A") +
scale_color_brewer(palette = "Set1", direction = -1) + scale_fill_brewer(palette = "Set1", direction = -1) +
geom_vline(
xintercept = 50,
linetype = "dashed",
color = "black",
size = 0.25
) + theme(legend.position = "none")
##
## Probability of History-congruence depending on perceptual accuracy
##
gathercol <- colnames(Sim_Behav_diff[3])
Sim_Behav_diff_long  <-
gather(Sim_Behav_diff,
"Variable",
"Frequency",
gathercol,
factor_key = TRUE)
Sim_Behav_diff_long$Accuracy <- as.character(Sim_Behav_diff_long$Accuracy)
Sim_Behav_diff_long$Accuracy <-
gsub("0", "error", Sim_Behav_diff_long$Accuracy)
Sim_Behav_diff_long$Accuracy <-
gsub("1", "correct", Sim_Behav_diff_long$Accuracy)
sim_p_distribution_Behav_diff <- ggplot(Sim_Behav_diff_long, aes(x = Frequency, color = -Accuracy, fill = Accuracy)) +
# geom_histogram(aes(y=..density..), colour="white", fill="black", position="identity", binwidth = 0.25, bins = 100, alpha = 0.3) +
geom_density(colour = "white", alpha=.4, bw = 0.75, size = 0.5) +
theme_classic(base_size = 6) +  xlim(25 , 100) + labs(x = "Frequency of History-congruence (%)",  y = "Density", subtitle = NULL, fill = "") +
scale_color_brewer(palette = "Set1", direction = -1) + scale_fill_manual(values = c("#4292C6", "#084594")) +
geom_vline(
xintercept = 50,
linetype = "dashed",
color = "black",
size = 0.25
) + theme(legend.position = "bottom")
##
## Acf Plot
##
Plot_Acf_Data =  Sim_Summary_acf[(Sim_Summary_acf$Variable == "diff_acf_Stimulus" | Sim_Summary_acf$Variable == "diff_acf_History") ,]
Plot_Acf_Data$Variable <- gsub("diff_acf_Stimulus", "Stimulus", Plot_Acf_Data$Variable)
Plot_Acf_Data$Variable <- gsub("diff_acf_History", "History", Plot_Acf_Data$Variable)
y_min = -0.002
sim_p_acf <- ggplot() +
geom_point(data = Plot_Acf_Data,
aes(
x = Trial,
y = Mean,
fill = Variable,
color = Variable),
alpha = 0.8,
size = 1,
fill = "white",
position = position_dodge(width = 0.5)
) +  geom_point(data = Plot_Acf_Data[Plot_Acf_Data$p == "< 0.05",],
aes(
x = Trial,
y = y_min,
fill = Variable,
color = Variable),
alpha = 0.8,
size = 0.1,
fill = "white",
position = position_dodge(width = 0.5)
) +
geom_errorbar(data = Plot_Acf_Data,
aes(
x = Trial,
ymin = Mean - Error,
ymax = Mean + Error,
fill = Variable,
color = Variable), position = position_dodge(width = 0.5), width = 0.5, alpha = 0.5, size = 0.5) + geom_line(data = Plot_Acf_Data,
aes(
x = Trial,
y = Mean,
fill = Variable,
color = Variable), position = position_dodge(width = 0.5), linetype = "dotted") +
geom_hline(
yintercept = 0,
linetype = "dashed",
color = "black",
size = 0.25
) +
theme_classic(base_size = 6) + labs(x = "Lag (Trials)",  y =
paste("Autocorrelation coefficient"), subtitle = "B", color = "Congruence to", shape = "p value") + xlim(0, 25.5) + scale_color_brewer(palette = "Set1", direction = -1) + theme(legend.position = c(0.8, 0.9), legend.box = "horizontal") +  scale_x_continuous(breaks = seq(1,25,by = 4), labels = seq(1,25,by = 4), limits=c(0, 25)) #+ ylim(-0.004, 0.03)
##
## Exceed Plot
##
gathercol <- colnames(ID_Sim_Summary_acf[,c(3,4)])
ID_Sim_Summary_acf_long  <-
gather(ID_Sim_Summary_acf,
"Variable",
"Lag",
gathercol,
factor_key = TRUE)
sim_p_exceed_acf <- ggplot(ID_Sim_Summary_acf_long, aes(x = Lag, fill = Variable)) +
geom_histogram(aes(y=..density..), color = "white", position="identity", binwidth = 1, bins = 100, alpha = 0.4, size = 0.5) +
#geom_density(alpha=.4, color = "white", bw = 1) +
theme_classic(base_size = 6) +  xlim(-1 ,12) + labs(x = "Positive autocorrelation (Trials)",  y = "Density", subtitle = "C") +
scale_color_brewer(palette = "Set1") + scale_fill_brewer(palette = "Set1")  + theme(legend.position = "none") + scale_x_continuous(breaks = seq(0,10,by=1), limits=c(-1, 11)) + facet_wrap(~Variable, nrow = 2) + theme(strip.background = element_blank(), strip.text = element_blank())
##
## Power Spectra
##
Sim_p_power_frequency <-
ggplot(data = Sim_Power_Frequency[Sim_Power_Frequency$r_freq > 0.01 & Sim_Power_Frequency$r_freq < 0.09,],
mapping = aes(x = (r_freq), y = (mean_power), ymin = (mean_power - ci_power), ymax = (mean_power - ci_power), color = Variable, group = Variable, fill = Variable)) +
geom_point(size = 0.5, alpha = 0.1) +
theme_classic(base_size = 6) +
theme(legend.position = "none") + stat_smooth(position = "identity", method = "loess", se = TRUE, n = 180, fullrange = TRUE,
level = 0.95, na.rm = TRUE, alpha = 0.2, size = 0.15) + xlim(0.01, 0.09) + ylim(0, 0.2) + scale_color_brewer(palette = "Set1", direction = 1) + scale_fill_brewer(palette = "Set1", direction = 1) +  labs(x = "Frequency",  y = "Spectral Density", subtitle = "D")
Sim_p_density_phase <-
ggplot(Sim_Power_Spectra[Sim_Power_Spectra$r_freq > 0.01 & Sim_Power_Spectra$r_freq < 0.09,], aes(
x = abs(Phase)
))  + geom_density(alpha=.2, color = "white", fill="darkorchid4", bw = 0.01) + labs(x = "Phase",  y =
"Density", subtitle = "E") + theme_classic(base_size = 6) + theme(legend.position =
"none") +
geom_vline(xintercept = pi, linetype = "dashed",
color = "black",
size = 0.25) #+ xlim(-0.2, 3.4)
Sim_p_density_coherence <-
ggplot(Sim_Power_Spectra[Sim_Power_Spectra$bin_freq < 0.09,], aes(
x = Coherence
))  + geom_density(alpha=.2, color = "white", fill="darkorchid4", bw = 0.01) + labs(x = "Squared coherence (%)",  y =
"Density", subtitle = "F") + theme_classic(base_size = 6) + theme(legend.position =
"none") + geom_vline(xintercept = mean(Sim_Power_Spectra[Sim_Power_Frequency$r_freq > 0.01 & Sim_Power_Frequency$r_freq < 0.1,]$Coherence, na.rm = TRUE), linetype = "dashed",
color = "black",
size = 0.25) + xlim(-1, 26)
sim_p_Confidence_mode <- ggplot(data = Sim_Post_Perceptual_Modes[Sim_Post_Perceptual_Modes$n_percent > 0.5,], aes(
x = directed_mode,
y = average_Confidence,
ymin = average_Confidence - se_Confidence,
ymax = average_Confidence + se_Confidence)) +
geom_point(
alpha = 0.5,
size = 0.1,
fill = "darkorchid4",
position = position_dodge(width = 0)
) +
geom_errorbar(
width = 5, alpha = 0.5, size = 0.5, color = "darkorchid4") +
geom_line(linetype = "dotted", color = "darkorchid4") +
theme_classic(base_size = 6) +
labs(x = "Int.< Mode (%) > Ext.",  y =
"Simulated posterior certainty", subtitle = "H")  + scale_color_brewer(palette = "Set1", direction = -1) + theme(legend.position = "none") +  scale_x_continuous(breaks = seq(-100,100,by = 20), labels = seq(-100,100,by = 20), limits=c(-100, 100)) + stat_smooth(position = "identity", method = "loess", se = TRUE, n = 180, fullrange = TRUE,
level = 0.95, na.rm = TRUE, alpha = 0.2, size = 0.1, color = "darkorchid4", fill = "darkorchid4", linetype = "dashed") +
geom_hline(
yintercept = min(Sim_Post_Perceptual_Modes[Sim_Post_Perceptual_Modes$n_percent > 0,]$average_Confidence),
linetype = "dashed",
color = "black",
size = 0.25
) +
geom_vline(
xintercept = Sim_Post_Perceptual_Modes[Sim_Post_Perceptual_Modes$n_percent > 0 & Sim_Post_Perceptual_Modes$average_Confidence == min(Sim_Post_Perceptual_Modes[Sim_Post_Perceptual_Modes$n_percent > 0,]$average_Confidence),]$directed_mode,
linetype = "dashed",
color = "black",
size = 0.25
)
sim_p_Confidence <- ggplot() +
geom_point(data = Sim_Confidence_Behav_long,
aes(
x = Variable,
y = diff,
color = Variable),
alpha = 0.01,
size = 0.01,
fill = "white",
position = position_jitter(width = 0.1)
)  +
geom_errorbar(data = Summary_Sim_Confidence_Behav,
aes(
x = Variable,
ymin = Mean - Error,
ymax = Mean + Error,
color = Variable), position = position_dodge(width = 0.5), width = 0.125, alpha = 0.8, size = 0.5) +
theme_classic(base_size = 6) + labs(x = "Congruency",  y = "diff posterior certainty (zscore)", subtitle = "G") + scale_color_brewer(palette = "Set1", direction = -1) +   geom_hline(
yintercept = 0,
linetype = "dashed",
color = "black",
size = 0.25
) +  theme(legend.position = "none") + ylim(-0.1, 0.25)
lay <- rbind(c(1,2,2,3), c(8,2,2,3), c(4,5, 9,7), c(4,6,9,7))
grid.arrange(
sim_p_distribution_Behav, sim_p_acf, sim_p_exceed_acf,
Sim_p_power_frequency, Sim_p_density_phase, Sim_p_density_coherence,
sim_p_Confidence_mode, sim_p_distribution_Behav_diff, sim_p_Confidence,
layout_matrix = lay,
heights = c(0.5, 0.5, 0.4,0.4),
widths = c(0.3,0.2, 0.225,0.3))
##
## Latex smallest numbers
##
# smallest_value = .Machine$double.xmin
# replace p = \(0\) with p < \(\ensuremath{2.2\times 10^{-308}}\)
knitr::opts_chunk$set(echo = FALSE,
message = FALSE,
warning = FALSE)
options(scipen = -1, digits = 2)
##
## Global settings: what to do in R markdown (compute primary statistics vs. load data from disc)
##
##
## ROOT
##
#root = "/home/veithweilnhammer/Desktop/Modes Data/"
#root = "E:/Modes Data/"
root = "C:/Users/Veith Weilnhammer/Downloads/"
##
## Load/save fully preprocessed data
##
load_summary_data = FALSE
save_summary_data = FALSE
##
## Human Data
##
collect_data = FALSE
n_permutations = 100
compute_slider = FALSE
sliding_window = 10
additional_autocorrelations = FALSE
load_data = TRUE
compute_logreg = FALSE
compute_Tw_LogReg = FALSE
compute_sine_wave_fit = FALSE
compute_power_spectra = FALSE
compute_group_acf = FALSE
compute_training_history = FALSE
compute_metacognitive_sensitivity = FALSE
extract_additional_Slider_Data = FALSE
compute_sliding_log = FALSE
##
## Mouse data
##
preprocess_mouse_data = FALSE
compute_slider_mouse_data = FALSE
filter_mouse_data = FALSE
compute_pretraining_data_mouse = FALSE
load_mouse_data = TRUE
apply_mouse_exclusion_criteria = FALSE
compute_mouse_group_acf = FALSE
compute_mouse_power_spectra = FALSE
compute_mouse_logreg = FALSE
compute_slider_History_Accuracy_lmer = FALSE
compute_mouse_Tw_LogReg = FALSE
mouse_compute_RT_Accuracy_History = FALSE
compute_mouse_training_history = FALSE
extract_mouse_additional_Slider_Data = FALSE
##
## Optimization
##
run_optim_human = FALSE
run_optim_mouse = TRUE
## generate output from fitted data
generate_output_human = FALSE
run_logreg_Confidence_mu_minus_1 = FALSE
generate_output_mouse = FALSE
run_mouse_logreg_mu_minus_1 = FALSE
##
## Simulation
##
# visualize bias
run_visualize_bias_sim = FALSE
run_visualize_alt_sim = FALSE
# Adaptive simulation
run_adaptive_simulation = FALSE
# Posterior Parameters
run_simulation = FALSE
compute_power_spectra_simulation = FALSE
run_control_simulation = FALSE
compute_simulation_control_group_acf = FALSE
visualize_circular_inference = FALSE
#### General Markdown Settings
library(pander)
panderOptions('round', 2)
panderOptions('keep.trailing.zeros', TRUE)
library(knitcitations)
cleanbib()
cite_options(citation_format = "pandoc", check.entries = FALSE)
library(bibtex)
type_list = c(
"fit_glaze_osc_zeta_v1_mouse",
"fit_glaze_osc_zeta_v1_one_amp_mouse",
"fit_glaze_osc_zeta_v1_LLR_amp_mouse",
"fit_glaze_osc_zeta_v1_Prior_amp_mouse",
"fit_glaze_osc_zeta_v1_no_amp_mouse",
"fit_glaze_osc_zeta_v1_no_integration_mouse"
#"fit_glaze_osc_zeta_v1_random_walk_mouse"
)
source("./Functions/fit_glaze_osc_zeta_v1_mouse.R",
local = knitr::knit_global())
source("./Functions/fit_glaze_osc_zeta_v1_one_amp_mouse.R",
local = knitr::knit_global())
source("./Functions/fit_glaze_osc_zeta_v1_LLR_amp_mouse.R",
local = knitr::knit_global())
source("./Functions/fit_glaze_osc_zeta_v1_Prior_amp_mouse.R",
local = knitr::knit_global())
source("./Functions/fit_glaze_osc_zeta_v1_no_amp_mouse.R",
local = knitr::knit_global())
source( "./Functions/fit_glaze_osc_zeta_v1_no_integration_mouse.R",
local = knitr::knit_global()
)
source("./Functions/fit_glaze_osc_zeta_v1_random_walk_mouse.R",
local = knitr::knit_global()
)
block_size = 10
Optim_eval = data.frame()
for (id in min(MwData$subject_id)) {
print(paste("mouse:", id, sep = " "))
for (session_id in min(MwData[MwData$subject_id == id, ]$session_id)) {
print(paste("session:", session_id, sep = " "))
Input_Data = MwData[MwData$subject_id == id &
MwData$session_id == session_id, c("Stimulus", "Response", "Difficulty")]
Input_Data$Stimulus <-
(Input_Data$Stimulus * 2 - 1) * Input_Data$Difficulty
Input_Data$Stimulus[Input_Data$Difficulty == 0] = 0
Input_Data = Input_Data[!is.na(Input_Data$Stimulus) &
!is.na(Input_Data$Response), ]
if (nrow(Input_Data)  > block_size) {
for (trial_idx in seq(from = 1, to = nrow(Input_Data) - block_size  + 1, by = block_size)) {
#for (trial_idx  in c(1)) {
print(trial_idx)
train =  Input_Data[seq(from = trial_idx,
to = trial_idx + block_size  - 1,
by = 1), ]
for (type_idx in c(1:length(type_list))) {
#print(type_list[type_idx])
if (type_list[type_idx] == "fit_glaze_osc_zeta_v1_mouse") {
## Starting parameters
par = c(0.01, 0.01, 1, 1,  1 / 20, runif (1, 0, 2 * pi - pi / 1000), 5)
lower = c(0.01, 0.01, 0, 0, 1 / 40, 0, 1)
upper = c(0.99, 20, 4, 4, 1 / 5, 2 * pi - pi / 1000, 10)
}
if (type_list[type_idx] == "fit_glaze_osc_zeta_v1_one_amp_mouse") {
## Starting parameters
par = c(0.01, 0.01, 1,  1 / 20, runif (1, 0, 2 * pi - pi / 1000), 5)
lower = c(0.01, 0.01, 0, 1 / 40, 0, 1)
upper = c(0.99, 20, 4, 1 / 5, 2 * pi - pi / 1000, 10)
}
if (type_list[type_idx] == "fit_glaze_osc_zeta_v1_LLR_amp_mouse") {
## Starting parameters
par = c(0.01, 0.01, 1,  1 / 20, runif (1, 0, 2 * pi - pi / 1000), 5)
lower = c(0.01, 0.01, 0, 1 / 40, 0, 1)
upper = c(0.99, 20, 4, 1 / 5, 2 * pi - pi / 1000, 10)
}
if (type_list[type_idx] == "fit_glaze_osc_zeta_v1_Prior_amp_mouse") {
## Starting parameters
par = c(0.01, 0.01, 1,  1 / 20, runif (1, 0, 2 * pi - pi / 1000), 5)
lower = c(0.01, 0.01, 0, 1 / 40, 0, 1)
upper = c(0.99, 20, 4, 1 / 5, 2 * pi - pi / 1000, 10)
}
if (type_list[type_idx] == "fit_glaze_osc_zeta_v1_no_amp_mouse") {
## Starting parameters
par = c(0.01, 0.01, 5)
lower = c(0.01, 0.01, 1)
upper = c(0.99, 20, 10)
}
if (type_list[type_idx] == "fit_glaze_osc_zeta_v1_no_integration_mouse") {
## Starting parameters
par = c(0.01, 5)
lower = c(0.01, 1)
upper = c(20, 10)
}
if (type_list[type_idx] == "fit_glaze_osc_zeta_v1_random_walk_mouse") {
## Starting parameters
par = c(0.01, 0.01, 3, 0.1, 5)
lower = c(0.01, 0.01,-5, 0.01, 1)
upper = c(0.99, 20,+5, 1, 10)
}
add_O =  optimx(
par,
match.fun(type_list[type_idx]),
Input_Data = train,
lower = lower,
upper = upper
)
add_O$subject_id = id
add_O$session_id = session_id
add_O$block_id = trial_idx
add_O$trial_n = nrow(train)
add_O$free_param = length(par)
add_O$type = type_list[type_idx]
add_O$AIC = compute_AIC(
LL = -add_O$value,
K =  add_O$free_param,
n = add_O$trial_n,
correction = 0
)
add_O$cAIC = compute_AIC(
LL = -add_O$value,
K =  add_O$free_param,
n = add_O$trial_n,
correction = 1
)
Optim_eval = rbind(Optim_eval, add_O[, c('value', 'type', 'free_param')])
write.csv(Optim_eval,
"./Results/Optim_eval_mouse_interim.csv",
row.names = FALSE)
Sum <- ddply(Optim_eval,
.(type),
summarise,
LL = mean(abs(value), na.rm = TRUE))
print(Sum)
}
}
}
write.csv(Optim_eval,
"./Results/Optim_eval_mouse_interim.csv",
row.names = FALSE)
Sum <-   ddply(Optim_eval,
.(type),
summarise,
LL = mean(abs(value), na.rm = TRUE))
print(Sum)
}
}
head(MwData)
